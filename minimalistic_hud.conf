name: minimalistic hud

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual

handlers:
    library:
        start:
            lua: |
                -------------------
                -- DAMAGE REPORT MODULE
                -------------------
                -- LUA Parameters
                MINHUD_show_labels = true --export: show/hide view labels
                MINHUD_defaultFilter = 1 --export: 1 for all,2 for avionics and weapons,3 for avionics only, 4 for weapons only
                MINHUD_defaultView = 1 --export: 1 for top,2 for side and 3 for front
                MINHUD_show_txt_module = true --export: enable the ship damage text report
                MINHUD_dmg_priority = 2 --export: Show damaged components (3) Below 100%, (2) Below 75%, (1) Below 50%
                
                MINHUD_size_ratio = 1 --export: change the size of the ship layout, use positive or negative numbers
                MINHUD_top_position = 5 --export: change the left position of the ship layout (Increase to move right)
                MINHUD_left_position = 180 --export: change the top position of the ship layout (Increase to move down)
                MINHUD_label_position = 0 --export: move the view label left or right (useful for centering)
                
                MINHUD_txt_module_left_pos = 1 --export:  change the left position of the ship layout (Increase to move right)   
                MINHUD_txt_module_top_pos = 200 --export: change the top position of the ship layout (Increase to move down)
                
                
                MINHUD_dmg_refresh_rate = 0.25 --export: Damage report refresh rate every x seconds
                -------------------
                -- General Functions
                -------------------
                function round(num, numDecimalPlaces)
                    return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
                end
                
                function getElemCategory(elemtype)
                    elem_category="UNKNOWN"
                    if elemtype ~= nil then
                         local critical_part_list = {"DYNAMIC CORE","RESURRECTION NODE","RADAR","GUNNER MODULE","COMMAND SEAT CONTROLLER","COCKPIT"}   
                         local avionics_part_list = {"ENGINE","FUEL-TANK","ADJUSTOR","VERTICAL BOOSTER","RETRO-ROCKET BRAKE","WING","ATMOSPHERIC AIRBRAKE"}
                         local weapon_part_list = {"LASER","CANNON","MISSILE","RAILGUN"}    
                        -- CRITICALS
                        for _,reftype in ipairs(critical_part_list) do
                            if string.match(elemtype, reftype) then
                                elem_category="CRITICALS"
                                break
                            end    
                        end
                        if elem_category == "UNKNOWN" then
                            -- AVIONICS 
                            for _,reftype in ipairs(avionics_part_list) do
                                if string.match(elemtype, reftype) then
                                    elem_category="AVIONICS"
                                    break
                                end
                            end
                            if elem_category == "UNKNOWN" then
                                -- WEAPONS
                                for _,reftype in ipairs(weapon_part_list) do
                                    -- Avoid mistaking laser emitter for a weapon...
                                    if elemtype == "LASER" then
                                        elem_category="WEAPON"
                                        break 
                                    elseif string.match(elemtype, reftype) then
                                        elem_category="WEAPON"
                                        break
                                    end    
                                end 
                            end
                        end 
                    end
                    return elem_category
                end
                
                
                -------------------
                -- Element Class
                -------------------
                Element = {}
                Element.__index = Element
                
                function Element.new(elem_id,elem_type,elem_category, elem_name, elem_pos_x, elem_pos_y, elem_pos_z)
                    local self = setmetatable({}, Element)
                    self.elem_id = elem_id
                    self.elem_type = elem_type
                    self.elem_category = elem_category
                    self.elem_name = elem_name
                    self.elem_pos_x = elem_pos_x
                    self.elem_pos_y = elem_pos_y
                    self.elem_pos_z = elem_pos_z
                
                    return self
                end
                
                -------------------
                -- DamageModule Class
                -------------------
                DamageModule = {}
                DamageModule.__index = DamageModule
                
                function DamageModule.new()
                    local self = setmetatable({}, DamageModule)
                    self.elem_list = {}
                    self.elem_filter = MINHUD_defaultFilter -- 4 for all,3 for avionics and weapons,2 for avionics only, 1 for weapons
                    self.active_view = MINHUD_defaultView -- 1 for top,2 for side and 3 for front
                    self.last_time_updated = 0
                    --Default placement
                    self.dmg_module_size_ratio = 0
                
                    -- Getting the core offset
                    -- XS CORE
                    local core_offset = -5
                    self.dmg_module_size_ratio = 10
                
                    local core_hp = core.getElementHitPointsById(core.getId())
                    if core_hp > 10000 then
                        -- L CORE
                        core_offset = -128
                        self.dmg_module_size_ratio = 1
                    elseif core_hp > 1000 then
                        -- M CORE
                        core_offset = -64
                        self.dmg_module_size_ratio = 2
                    elseif core_hp > 150 then
                        -- S CORE
                        core_offset = -32
                        self.dmg_module_size_ratio = 5
                    end
                
                    self.core_offset=core_offset   
                    -- Adjustments
                    self.dmg_module_size_ratio=self.dmg_module_size_ratio+MINHUD_size_ratio
                
                    self.max_x= -999999999
                    self.min_x= 999999999
                    self.max_y= -999999999
                    self.min_y = 999999999
                    self.max_z= -999999999
                    self.min_z = 999999999
                
                
                    -- STORING SHIP ELEMENTS
                    for i,idelem in ipairs(core.getElementIdList()) do
                        local elem_type = core.getElementTypeById(idelem):upper()
                        local elem_categ = getElemCategory(elem_type)
                        local elem_name = core.getElementNameById(idelem)
                        local x,y,z = table.unpack(core.getElementPositionById(idelem))
                        x=(x+core_offset)*self.dmg_module_size_ratio
                        y=(y+core_offset)*self.dmg_module_size_ratio
                        z=(z+core_offset)*self.dmg_module_size_ratio
                        if self.min_x > x then
                            self.min_x = x
                        end    
                        if self.min_y > y then
                            self.min_y = y
                        end
                        if self.min_z > z then
                            self.min_z = z
                        end 
                        if self.max_x < x then
                            self.max_x = x
                        end    
                        if self.max_y < y then
                            self.max_y = y
                        end
                        if self.max_z < z then
                            self.max_z = z
                        end
                        self:add(Element.new(idelem,elem_type, elem_categ, elem_name, x, y, z))
                    end
                    -- Computing ship size
                    self.ship_width = 0
                    if self.min_x < 0 then
                        self.ship_width = self.ship_width + (self.min_x)*-1
                    else
                        self.ship_width = self.ship_width + self.min_x
                    end      
                    if self.max_x < 0 then
                        self.ship_width = self.ship_width + (self.max_x)*-1
                    else
                        self.ship_width = self.ship_width + self.max_x
                    end
                    self.ship_height = 0
                    if self.min_y < 0 then
                        self.ship_height = self.ship_height + (self.min_y)*-1
                    else
                        self.ship_height = self.ship_height + self.min_y
                    end      
                    if self.max_y < 0 then
                        self.ship_height = self.ship_height + (self.max_y)*-1
                    else
                        self.ship_height = self.ship_height + self.max_y
                    end
                    self.ship_z = 0
                    if self.min_z < 0 then
                        self.ship_z = self.ship_z + (self.min_z)*-1
                    else
                        self.ship_z = self.ship_z + self.min_z
                    end      
                    if self.max_z < 0 then
                        self.ship_z = self.ship_z + (self.max_z)*-1
                    else
                        self.ship_z = self.ship_z + self.max_z
                    end
                
                    return self
                end
                
                function DamageModule.add(self,element)
                    table.insert(self.elem_list, element)
                end
                
                function DamageModule.nextFilter(self)
                    if self.elem_filter < 4 then
                        self.elem_filter = self.elem_filter + 1
                    else 
                        self.elem_filter = 1 	    
                    end 
                end
                
                function DamageModule.nextView(self)
                    if self.active_view < 3 then
                        self.active_view = self.active_view + 1
                    else 
                        self.active_view = 1 	    
                    end 
                end
                
                function DamageModule.getActiveView(self)
                    return self.active_view
                end
                
                function DamageModule.renderCSS(self)
                    local css = [[
                    <style>
                    svg {
                    padding:10px;
                } 
                    .view {
                    position:absolute;
                    top:]]..MINHUD_top_position..[[px;
                    left:]]..MINHUD_left_position..[[px;
                }
                    .dmgdotlabel {
                    width:100%;
                    text-align:center;
                    font-size:1vh;
                    font-weight:bold;
                
                }
                    ]]
                    if MINHUD_show_txt_module == true then
                        css=css..[[
                        .title {
                        font-size:1vh;
                        text-align:center;
                        font-weight:bold;
                    }
                        .r {
                        text-align:right;
                    }
                        .dmgtxt {
                        text-align:center;
                        background-color: rgba(0, 0, 0, .4);
                        width: 9vw;
                        font-size:1vh;   
                        position:absolute;
                        left:]]..MINHUD_txt_module_left_pos..[[px;
                        top:]]..MINHUD_txt_module_top_pos..[[px;
                    }
                
                        .pristine {
                        color: #9BFFAC;
                    }
                        .ldmg {
                        color: #FFDD8E;
                    }
                        .mdmg {
                        color: #FF9E66;
                    }
                        .hdmg {
                        color: #FF2819;
                    }
                        .dead {
                        color: #7F120C;
                    }]]
                    end
                    css=css..[[</style>]]
                    return css
                end
                
                function DamageModule.renderHTML(self)
                    local front_view_html = ""
                    local side_view_html = ""
                    local top_view_html = ""
                    local table_view_html = ""
                    if system.getTime() > self.last_time_updated + MINHUD_dmg_refresh_rate then
                        --Data gathering
                        local dead_elem_list=""
                        local high_damage_list=""
                        local medium_damage_list=""
                        local light_damage_list=""
                        local label_x = self.max_x-self.min_x
                        local maxtoptv = -99999999999
                        local maxtopfv = -99999999999
                        local maxtopsv = -99999999999
                
                        for _,elem in ipairs(self.elem_list) do
                            local element_excluded = false
                            if self.elem_filter == 2 and elem.elem_category ~= "AVIONICS" and elem.elem_category ~= "WEAPON" and elem.elem_category ~= "CRITICAL" then
                                element_excluded = true
                            elseif self.elem_filter == 3 and elem.elem_category ~= "AVIONICS" and elem.elem_category ~= "CRITICAL" then
                                element_excluded = true
                            elseif self.elem_filter == 4 and elem.elem_category ~= "WEAPON" and elem.elem_category ~= "CRITICAL" then
                                element_excluded = true   
                            end    
                            if element_excluded == false then
                                local elem_hp = core.getElementHitPointsById(elem.elem_id)
                                local elemmax_hp = core.getElementMaxHitPointsById(elem.elem_id)
                                local elem_hp_percentage = (elem_hp*100)/elemmax_hp
                                local color=""
                                local opacity=0.2
                                elem_hp_percentage = round(elem_hp_percentage)
                                if elem_hp_percentage >= 100 then
                                    color="#9BFFAC"
                                elseif elem_hp_percentage >= 75 then
                                    opacity=0.3
                                    color="#FFDD8E"
                                    if MINHUD_dmg_priority > 2 then
                                        light_damage_list=light_damage_list..[[<tr class="ldmg"><td>]]..elem.elem_name..[[</td><td class="r">]]..elem_hp_percentage..[[%</td></tr>]]
                                    end
                                elseif elem_hp_percentage >= 50 then
                                    color="#FF9E66"
                                    opacity=0.4
                                    if MINHUD_dmg_priority > 1 then
                                        medium_damage_list=medium_damage_list..[[<tr class="mdmg"><td>]]..elem.elem_name..[[</td><td class="r">]]..elem_hp_percentage..[[%</td></tr>]]
                                    end
                                elseif elem_hp_percentage > 0 then
                                    color="#FF2819"
                                    opacity=0.5
                                    high_damage_list=high_damage_list..[[<tr class="hdmg"><td>]]..elem.elem_name..[[</td><td class="r">]]..elem_hp_percentage..[[%</td></tr>]]
                                elseif elem_hp_percentage == 0 then
                                    color="#7F120C"
                                    opacity=1
                                    dead_elem_list=dead_elem_list..[[<tr class="dead"><td>]]..elem.elem_name..[[</td><td class="r">0%</td></tr>]]
                                end
                                local left = 0
                                local top = 0
                                -- We are using quadrants to place points correctly
                                -- 1 2
                                -- 3 4
                                if (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then    
                                    -- 1
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_y - elem.elem_pos_y
                                elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then    
                                    -- 2
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_y - elem.elem_pos_y
                                elseif (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then    
                                    -- 3
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_y + (elem.elem_pos_y*-1)
                                elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then    
                                    -- 4
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_y + (elem.elem_pos_y*-1)
                                end    
                                -- Top view x,y
                                if maxtoptv < top then
                                    maxtoptv = top
                                end 
                                top_view_html = top_view_html..[[<circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" />]]
                                -- Front view x,z
                                if (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then    
                                    -- 1
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_z - elem.elem_pos_z
                                elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then    
                                    -- 2
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_z - elem.elem_pos_z
                                elseif (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then    
                                    -- 3
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_z + (elem.elem_pos_z*-1)
                                elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then    
                                    -- 4
                                    left = (self.min_x*-1) + elem.elem_pos_x
                                    top = self.max_z + (elem.elem_pos_z*-1)
                                end 
                                if maxtopfv < top then
                                    maxtopfv = top
                                end 
                                front_view_html = front_view_html..[[<circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" />]]
                                -- Side view y,z
                                if (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then    
                                    -- 1
                                    left = (self.min_y*-1) + elem.elem_pos_y
                                    top = self.max_z - elem.elem_pos_z
                                elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then    
                                    -- 2
                                    left = (self.min_y*-1) + elem.elem_pos_y
                                    top = self.max_z - elem.elem_pos_z
                                elseif (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then    
                                    -- 3
                                    left = (self.min_y*-1) + elem.elem_pos_y
                                    top = self.max_z + (elem.elem_pos_z*-1)
                                elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then    
                                    -- 4
                                    left = (self.min_y*-1) + elem.elem_pos_y
                                    top = self.max_z + (elem.elem_pos_z*-1)
                                end 
                                if maxtopsv < top then
                                    maxtopsv = top
                                end 
                                side_view_html = side_view_html..[[<circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" />]]
                            end 
                        end
                        -- Text damage report
                        --Adding filter label below
                        local filter_label = "ALL"
                        if self.elem_filter == 2 then
                            filter_label = "WP & AV"
                        elseif self.elem_filter == 3 then
                            filter_label = "AVIONICS"
                        elseif  self.elem_filter == 4 then
                            filter_label = "WEAPONS"
                        end
                        -- Top view code x,y
                        top_view_html=[[<div class="view top_view"><svg width="1000" height="1000">]]..top_view_html
                        if MINHUD_show_labels == true then
                            top_view_html=top_view_html..[[<text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtoptv+30)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">TOP</text><text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtoptv+45)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">]]..filter_label..[[</text>]]
                        end
                        top_view_html=top_view_html..[[</svg></div>]]
                
                        -- front view code x,z
                        front_view_html=[[<div class="view front_view"><svg width="1000" height="1000">]]..front_view_html
                        if MINHUD_show_labels == true then
                            front_view_html=front_view_html..[[<text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtopfv+30)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">FRONT</text><text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtopfv+45)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">]]..filter_label..[[</text>]]
                        end
                        front_view_html=front_view_html..[[</svg></div>]]
                        -- side view y,z
                        side_view_html=[[<div class="view side_view"><svg width="1000" height="1000">]]..side_view_html
                        if MINHUD_show_labels == true then
                            side_view_html=side_view_html..[[<text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtopsv+30)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">SIDE</text><text x="]]..(label_x/2)+MINHUD_label_position..[[" y="]]..(maxtopsv+45)..[[" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="white">]]..filter_label..[[</text>]]
                        end    
                        side_view_html=side_view_html..[[</svg></div>]]
                        table_view_html = table_view_html..[[<div class="dmgtxt"><div class="title">Damage Report :<br>]]..filter_label..[[</div><hr><table style="width:100%;">]]..dead_elem_list..high_damage_list..medium_damage_list..light_damage_list..[[</table></div>]]
                    end
                    return {top_view_html,front_view_html,side_view_html,table_view_html}
                end
    library:
        start:
            lua: |
                -------------------
                -- FUEL MODULE
                -------------------
                -- LUA Parameters
                MINHUD_show_fuel = true --export: Enable the fuel module
                MINHUD_fuel_left_position = 1 --export: Fuel module position from the left of the HUD
                MINHUD_fuel_top_position = 0 --export: Fuel module position from the top side of the HUD
                MINHUD_fuel_refresh_rate = 0.25 --export: Fuel module refresh rate every x seconds
                MINHUD_fuel_show_remaining_time = 10 --export: If fuel is lasting more than x hours, do not show remaining time, 0 to always show remaining time

                -------------------
                -- FUEL CLASS
                -------------------
                FuelModule = {}
                FuelModule.__index = FuelModule

                function FuelModule.new()
                    local self = setmetatable({}, FuelModule)
                    self.html = ""
                    self.last_time_updated = 0
                    if MINHUD_show_fuel == true then
                       if standard_atmo_fuel_module ~= nil then
                             system.destroyWidgetPanel(standard_atmo_fuel_module)
                             standard_atmo_fuel_module = nil
                       end
                       if standard_space_fuel_module ~= nil then
                             system.destroyWidgetPanel(standard_space_fuel_module)
                             standard_space_fuel_module = nil
                       end
                       if standard_rocket_fuel_module ~= nil then
                             system.destroyWidgetPanel(standard_rocket_fuel_module)
                             standard_rocket_fuel_module = nil
                       end
                    end
                    return self
                end

                function FuelModule.computeData(self,fuel_tank)
                    local fuel_percentage = ""
                    local fuel_time_to_empty = ""

                    local obj, pos, err = json.decode(fuel_tank.getData(), 1, nil)
                    if err then
                    else
                        -- Computing fuel percentage
                        if obj.percentage ~= nil then
                            fuel_percentage = obj.percentage
                        end
                        -- Computing time left thanks to data in seconds
                        if obj.timeLeft ~= nil and obj.timeLeft ~= "" then
                            local time_left = tonumber(obj.timeLeft)
                            if time_left ~= nil then
                                -- DAYS (86 400 seconds are one day)
                                local days = time_left // 86400
                                -- Modulus to get hours lefts
                                time_left = time_left % 86400
                                -- HOURS (3600 seconds are one hour)
                                local hours = time_left // 3600
                                -- Modulus again to get minutes lefts
                                time_left = time_left % 3600
                                -- MINUTES (60 seconds are 1 minute) 
                                local minutes = time_left // 60
                                -- Modulus again to get minutes lefts
                                time_left = time_left % 60
                                local seconds = time_left
                                -- To avoid useless infos we show only if we have 99 days of autonomy
                                if days < 99 then                   
                                    local truehours = tonumber(obj.timeLeft) // 3600
                                    if (MINHUD_fuel_show_remaining_time==0 or MINHUD_fuel_show_remaining_time>=truehours) then
                                        if days > 0 then
                                            fuel_time_to_empty = " | "..tonumber(string.format("%."..(0).."f",days)).."d:"..tonumber(string.format("%."..(0).."f",hours)).."h:"..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"  
                                        elseif hours>0 then
                                            fuel_time_to_empty = " | "..tonumber(string.format("%."..(0).."f",hours)).."h:"..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"         
                                        elseif minutes>0 then
                                            fuel_time_to_empty = " | "..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"            
                                        elseif seconds>0 then
                                            fuel_time_to_empty = " | "..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"                
                                        end        	 
                                    end
                                end    
                            end      
                        end          
                    end
                    return {fuel_percentage,fuel_time_to_empty}
                end

                function FuelModule.renderHTML(self)
                    if MINHUD_show_fuel == true then
                        -- Limiting refresh
                        if system.getTime() > self.last_time_updated + MINHUD_fuel_refresh_rate then
                            self.last_time_updated = system.getTime()
                            -- CSS           
                            self.html = [[
                            <style>
                            #progress {
                            opacity:0.8;
                            width: 8vw;   
                            background-color:black;
                            position: relative;
                        }
                            #percent {
                            color:white;
                            font-weight:bold;
                            position: absolute; 
                            font-size:1.2vh;
                            left: 4%;
                        }
                            #bar {
                            height: 1.4vh;
                        }
                            .fuelmodule {
                            position:absolute;
                            top:]]..MINHUD_fuel_top_position..[[px;
                            left:]]..MINHUD_fuel_left_position..[[px;
                        }
                            </style>
                            <div class="fuelmodule">
                            <table>
                            ]]
                            -- ATMO    
                            for _,f_tank in ipairs(atmofueltank) do
                                local ft_data = self:computeData(f_tank)
                                self.html=self.html..[[<tr><td><div id="progress"><span id="percent">]]..ft_data[1]..[[%]]..ft_data[2]..[[</span><div id="bar" style="background-color:#8FC3BD;width:]]..ft_data[1]..[[%;"></div></td></tr>]]
                            end
                            -- SPACE
                            for _,f_tank in ipairs(spacefueltank) do
                                local ft_data = self:computeData(f_tank)
                                self.html=self.html..[[<tr><td><div id="progress"><span id="percent">]]..ft_data[1]..[[%]]..ft_data[2]..[[</span><div id="bar" style="background-color:#BCB83C;width:]]..ft_data[1]..[[%;"></div></td></tr>]]
                            end
                            -- ROCKET
                            for _,f_tank in ipairs(rocketfueltank) do
                                local ft_data = self:computeData(f_tank)
                                self.html=self.html..[[<tr><td><div id="progress"><span id="percent">]]..ft_data[1]..[[%]]..ft_data[2]..[[</span><div id="bar" style="background-color:#937E97;width:]]..ft_data[1]..[[%;"></div></td></tr>]]
                            end 

                            --CLOSING TABLE 
                            self.html=self.html..[[</table></div>]]
                        end    
                    end    
                    return self.html    
                end
    library:
        start:
            lua: |
                            -------------------
                            -- WARP MODULE
                            -------------------
                            -- LUA Parameters
                            MINHUD_show_warp = true --export: Enable the warp module
                            MINHUD_warp_left_position = 1--export: Warp module position from the left of the HUD
                            MINHUD_warp_top_position = 120 --export: Warp module position from the top side of the HUD
                            MINHUD_warp_refresh_rate = 0.25 --export: Warp module refresh rate every x seconds
                            
                            -------------------
                            -- WARP UTILITIES
                            -------------------
                            -- Function extracted from DU-Orbital-Hud by Dimencia
                            function getDistanceDisplayString(distance)
                                local su = distance > 100000
                                local result = ""
                                if su then
                                    -- Convert to SU
                                    result = round(distance / 1000 / 200, 1) .. " SU"
                                elseif distance < 1000 then
                                    result = round(distance, 1) .. " M"
                                else
                                    -- Convert to KM
                                    result = round(distance / 1000, 1) .. " KM"
                                end
                            
                                return result
                            end
                            -------------------
                            -- WARP CLASS
                            -------------------
                            WarpModule = {}
                            WarpModule.__index = WarpModule
                            
                            function WarpModule.new()
                                local self = setmetatable({}, WarpModule)
                                self.html = ""
                                self.last_time_updated = 0
                                if MINHUD_show_warp == true then
                                    if warpdrive ~= nil then warpdrive.hide() end
                                end
                                return self
                            end
                            
                            
                            function WarpModule.renderHTML(self)
                                if (MINHUD_show_warp == true and warpdrive ~= nil) then
                                    -- Limiting refresh
                                    if system.getTime() > self.last_time_updated + MINHUD_warp_refresh_rate then
                                        local obj, pos, err = json.decode(warpdrive.getData(), 1, nil)
                                        if err then
                            
                                        else
                                            self.html = [[
                                            <style>
                                            .warp_mod {
                                            padding:5px;
                                            width: 9vw;  
                                            font-weight:bold;
                                            background-color: rgba(0, 0, 0, .4);
                                            position:absolute;
                                            top:]]..MINHUD_warp_top_position..[[px;
                                            left:]]..MINHUD_warp_left_position..[[px;
                                            font-size:1vh;
                                            color:white;
                                        }
                                            </style>
                                            ]]
                                            local hint = ""
                                            if obj.buttonMsg == "Activate Warp" then
                                                hint = " (Alt + J)"
                                            end    
                                            self.html = self.html..[[<div class="warp_mod"><div>]]..obj.buttonMsg..hint..[[</div><div style="background-color:red;color:white">]]..obj.errorMsg..[[</div><div>Dest : ]]..obj.destination..[[</div><div>Dist : ]]..getDistanceDisplayString(obj.distance)..[[</div><div>Cells : ]]..obj.cellCount..[[</div></div>]]
                                        end
                                    end    
                                end
                                return self.html
                            end
    library:
        start:
            lua: |
                -------------------
                -- RADAR UTILITY FUNCTIONS
                -------------------
                --function to split a string into an arrow using a delimeter
                function split(s, delimiter)
                    result = {};
                    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
                        table.insert(result, match);
                    end
                    return result;
                end
                
                --function to take a substring from another, identified between to known chars/set of chars, error if chars not found
                function Str_Cut(str,s_begin,s_end)
                    local StrLen = string.len(str)
                    local s_begin_Len = string.len(s_begin)
                    local s_end_Len = string.len(s_end)
                    local s_begin_x = string.find(str, s_begin, 1)
                    --print(s_begin_x)
                    local s_end_x = string.find(str, s_end, s_begin_x+1)
                    --print(s_end_x)
                    local rs=(string.sub(str, s_begin_x+s_begin_Len, s_end_x-1))
                    return rs
                end
                
                
                -------------------
                -- WEAPON MODULE
                -------------------
                MINHUD_show_weapon = true --export: show/hide weapon module
                MINHUD_weapon_refresh_rate = 0.25 --export: Weapon refresh rate every x seconds
                
                WeaponModule = {}
                WeaponModule.__index = WeaponModule
                
                function WeaponModule.new()
                    local self = setmetatable({}, WeaponModule)
                    self.html = ""
                    self.last_time_updated = 0
                    return self
                end
                
                function WeaponModule.renderHTML(self)
                    if MINHUD_show_weapon and weapon_size>0 and radar_size>0 then
                        if system.getTime() > self.last_time_updated + MINHUD_weapon_refresh_rate then
                            local idtarget=nil
                            self.html=[[<style>
                            .cat {
                            color:black;
                            background-color:white;
                        }
                            .wptxt {
                            text-align:center;
                            background-color: rgba(0, 0, 0, .4);
                            width: 9vw;
                            font-size:1vh;   
                            position:absolute;
                            left:]]..(MINHUD_txt_module_left_pos+180)..[[px;
                            top:]]..(MINHUD_txt_module_top_pos+27)..[[px;
                        }</style><div class="wptxt">]]
                            -- Draw hud for each weapons
                            for i,current_wp in ipairs(weapon) do
                                local obj, pos, err = json.decode(current_wp.getData(), 1, nil)
                                if err then
                                    system.print("Error:", err)
                                else
                                    self.html = self.html..[[<div class="title"><hr>]]..obj.name..[[<br><hr><table style="width:100%;">]]
                                    self.html = self.html..[[<tr><td class="cat" rowspan="2">A<br>M<br>M<br>O</td><td>type</td><td class="r">]]..obj.properties.ammoName..[[</td></tr>]]
                                    if obj.properties.ammoCount == nil or obj.properties.ammoCount == 0 then
                                        self.html = self.html..[[<tr><td style="background-color:red;" colspan="2">RELOAD !</td></tr>]]
                                    else
                                        self.html = self.html..[[<tr><td>Remaining</td><td class="r">]]..obj.properties.ammoCount..[[</td></tr>]]
                                    end    
                                    self.html = self.html..[[<tr><td colspan="3"><hr></td></tr>]]
                                    self.html = self.html..[[<tr><td class="cat" rowspan="3">F<br>O<br>E</td>]]
                                    if obj.targetConstruct ~= nil and obj.targetConstruct.constructId ~= nil and obj.targetConstruct.constructId ~= "0" and obj.properties.outOfZone == true then
                                        self.html = self.html..[[<td colspan="2" style="background-color:red;">OUT OF RANGE</td></tr>]]
                                    elseif obj.targetConstruct ~= nil and obj.targetConstruct.constructId ~= nil and obj.targetConstruct.constructId ~= "0" and obj.properties.outOfZone == false then
                                        local hitchance = round(obj.properties.hitProbability*100,2)
                                        local color="red"
                                        if hitchance>75 then
                                            color="green"
                                        elseif hitchance>50 then
                                            color="yellow"  
                                        elseif hitchance>35 then
                                            color="orange"
                                        end    
                                        self.html = self.html..[[<td colspan="2" style="background-color:]]..color..[[;font-size:2vh;">]]..hitchance..[[%</td></tr>]]    
                                    else
                                        self.html = self.html..[[<td colspan="2">NO TARGET</td></tr>]]
                                    end    
                                    self.html = self.html..[[</table></div>]]
                                    -- Target info
                                    if obj.targetConstruct ~= nil then
                                        idtarget = obj.targetConstruct.constructId
                                    end    
                                end
                            end  
                
                            if idtarget ~= nil and tonumber(idtarget)>0 then
                                -- To avoid CPU OVERLOAD, it is smarter to cut the radar contact list
                                local data = split(radar[1].getData(),idtarget.."\",")
                                if data ~= nil and data[2] ~= nil then
                                    data = split(data[2],",\"targetThreatState") 
                                    local target_data = data[1]
                                    if  target_data ~= nil then
                                        local obj, pos, err = json.decode("{"..target_data.."}", 1, nil)
                                        if err then
                                            system.print("Error:", err)
                                        else 
                                            self.html=self.html.."<br>Target<br><b>"..obj.name.."</b><hr>"
                                            self.html=self.html.."Size<br><b>"..obj.size.."</b><hr>"
                                            self.html=self.html.."Distance<br><b>"..getDistanceDisplayString(obj.distance).."</b>"
                                        end
                                    end
                                end  
                            end
                        end
                    end    
                    return self.html.."</div>"
                end
    unit:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
                
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    standard_atmo_fuel_module = _autoconf.panels[_autoconf.panels_size]
                    if placeRadar and MINHUD_show_fuel==false then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    standard_space_fuel_module = _autoconf.panels[_autoconf.panels_size]
                    if placeRadar and MINHUD_show_fuel==false then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                standard_rocket_fuel_module = _autoconf.panels[_autoconf.panels_size]
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end
                -- minimalistic hud
                fm = FuelModule.new()
                wm = WarpModule.new()
                wp = WeaponModule.new()
                dmgrep = DamageModule.new()
                system.showScreen(1)
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

    system:
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: |
                Nav:update()
                -- minimalistic hud
                fuel_html=fm:renderHTML()
                warp_html=wm:renderHTML()
                wp_html=wp:renderHTML()
                damage_html=dmgrep:renderHTML()
                damage_css=dmgrep:renderCSS()
                -- Show the selected view
                i = dmgrep:getActiveView() 
                txt_view = ""
                if MINHUD_show_txt_module == true then
                txt_view=damage_html[4]
                end
                system.setScreen(fuel_html..warp_html..damage_css..damage_html[i]..txt_view..wp_html)

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)

        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        actionStart:
            args: [warp]
            lua: if warpdrive ~= nil then warpdrive.activateWarp() end
        actionStart:
            args: [option1]
            lua: dmgrep:nextFilter()
        actionStart:
            args: [option2]
            lua: dmgrep:nextView()
